# 📗 학교에서 알려주지 않는 17가지 실무 개발 기술
## Part 1. 소프트웨어를 지탱하는 기술
### 문자열 인코딩
- 2진법을 사용하는 컴퓨터가 인간의 언어를 일정한 규칙에 따라 2진수로 변환하는 방식.
- 글자가 깨지거나, 보이지 않는 문제가 발생하는 이유? 호환되지 않는 문자열 인코딩을 사용하여 문자를 읽었기 때문이다.
- 모든 개발 환경이 유니코드를 동일하게 처리하지 않아, 개발자는 유니코드 문자열 인코딩 방식(UTF - 8, UTF - 16, UTF - 32) 중 하나를 택해야 한다.
- ASCII, EUC - KR, 유니코드(UTF - 8, UTF - 16, UTF - 32)
- 국내에서 만든 서비스를 연동할 때는 EUC-KR을 사용하는 경우가 있으니 주의해야 한다. ex) KG Inicis

### 다국어 처리
- i18n은 다국어를 지원하기 위해 만든 표준으로 국제화의 첫 문자(i)와 마지막 문자(n) 사이에 문자 18개가 있다는 것을 의미한다. 이를 사용하면 프로그램이 출력할 문장을 코드로부터 분리하고, 코드 수정이나 재컴파일 없이 시스템/브라우저 설정에 따라 적절한 언어를 출력할 수 있다.
- 다국어 지원을 위해 서비스나 코드를 별도로 관리하지 않아도 i18n을 사용하면 해결할 수 있다. 프로그램 코드는 출력할 문장의 식별자만 지정하면 되고, 실제 문장은 별도 파일에서 관리한다.
- i18n은 더 이상 사용하지 않는 문장이나 누락된 문장들을 자동으로 감지한다. 누락 검사 불필요.
- 하지만 안드로이드나 iOS는 각각 안드로이드 스튜디오와 XCode에서 다국어 처리를 지원하기에 모바일 개발자라면 이 방법을 사용하는 것이 좋다.

### 날짜와 시간
- 타임 스탬프는 컴퓨터가 시간을 표현하기 위해 사용하는 값이다. 1970년 1월 1일 0시 0분 0초부터 1초 단위로 증가한다.
- 컴퓨터는 타임 스탬프로 두 종류의 시간을 표현할 수 있다. 단조 시간과 실제 시간.

#### 단조 시간
- 단조 시간은 운영 체제 또는 CPU와 같은 하드웨어에서 직접 계산하는 시간이다.
- 실제 세계 시간과는 다르지만, 운영 체제가 시작한 이후 시점부터 바뀌지 않는다.
- 사용자가 직접 값을 변경할 수도 없다. 하지만 시스템 재부팅 이후에는 값이 초기화 된다.
- 외부 요인에 의해 바뀌지 않고 점진적으로 증가하기에 불변성을 보장하는 시간 값이 필요할 때 유용하게 사용한다. 
- 두 작업 사이에 걸린 시간을 측정하거나, 일정한 시간 간격마다 수행해야 하는 작업의 시간을 측정해야 할 때 사용한다.

#### 실제 시간
- 벽 시계 시간
- 주기적으로 시간 서버로부터 값을 가져와 동기화하기 때문에 언제든지 시간이 바뀔 수 있다.
- 실제 세계의 시간과 항상 일치한다.
- 한 달을 넘는 주기로 수행하는 작업이나 특정 날짜에 반드시 실행해야 하는 작업 등의 기준 시간으로 사용할 수 있다.
- 사용자나 시스템 등의 외부 환경에 의해 언제든지 시간 값이 바뀔 수 있기에 끝나야 할 작업이 끝나지 않거나, 끝나지 말아야 할 작업이 조기 종료될 수 있으니 주의해야 한다.
- 실제 시간을 사용할 때는 타임 존 설정을 꼭 확인해야 한다. 나라마다 사용하는 표준 시간이 다르기 때문이다.

### 정규 표현식
- 주어진 문자열 속에서 특정 패턴을 가진 문자열을 찾을 때 사용한다.
- 여러 문자열로부터 패턴을 가진 정보를 찾아야 할 때 유용하다.
- 소문자 1개 [a-z]
- 대문자 1개 [A-Z]
- 대소문자 1개 [a-zA-Z]
- 숫자 1개 [0-9]
- 1개 이상일 경우 뒤에 중괄호 사용 [a-z0-9]{3}

### 범용 고유 식별자 UUID
- 컴퓨터 시스템 내에서 고유한 객체를 식별하기 위해 사용하는 값.
- 네트워크 상에 존재하는 여러 컴퓨터를 식별하기 위해 사용하기 시작했다.
- 하이픈(-) 4개와 16진수 32개로 구성되었다.
- 8개-4개-4개-4개-12개 구조를 반드시 유지해야 한다.
- 하이픈을 생략하는 경우도 많다.
- 100경의 UUID를 생성했을 때 1쌍의 UUID가 충돌할 확률이 50%로, 고유 식별자로 사용하기엔 충분한 확률이다.

#### 버전
- 버전별로 사용 방법과 규칙이 다르다.
- 현재는 버전 4 UUID나 이를 기반으로 직접 정의한 UUID를 사용한다.

#### 버전 1, 2
- 버전 1: 컴퓨터의 맥 주소와 타임 스탬프 값을 기반으로 생성.
- 버전 2: 규모가 큰 시스템 환경을 고려해 자릿수 일부를 지역별 정의로 남겨둠.
- 마이크로 서비스 아키텍쳐는 맥 주소가 달라도 같은 서버로 인식해야 하고, 도커와 같은 가상 서버는 같은 맥 주소를 가진 여러 서버를 동시에 생성할 수 있기에 더이상 사용하지 않는다.

#### 버전 3, 5
- 네임스페이스와 문자열을 받아 해시 함수를 사용해 UUID로 변환한다.
- 입력값이 같으면 UUID도 같다는 특성이 있다.
- 해시 충돌을 막기 위해 별도의 네임스페이스 UUID를 받는다.

#### 버전 4
- 버전을 표기하는 4비트를 제외한 나머지 122비트를 모두 무작위로 생성한다.

#### 잘 사용하지 않는 이유
- 16바이트의 사용: 게시판에 글 번호를 추가할 때 1씩 증가하는 식별자를 사용하는 것이 16바이트를 사용하는 UUID보다 효율적이다.
- 정보 식별 문제: 무작위로 생성된 글자 32개를 사용하기 때문에 구체적인 내용을 알기가 어렵다. 로그를 출력했을 때 요청 주소, 메서드 등을 알 수 없기에 문제가 생긴 지점을 추적하는데에 문제가 된다.

### 난수
- 무작위로 생성된 값.
- 난수 값은 소프트웨어의 다양한 곳에서 정수, 실수, 16진수 형태로 가공해 사용한다.

#### 유사 난수
- 컴퓨터는 이론적으로 주어진 명령을 실행하는 기계라 완벽한 난수를 생성할 수 없다.
- 그래서 컴퓨터는 난수표, 난수 알고리즘, 알고리즘 초기화에 사용할 시드 값으로 난수를 만든다.
- 이러한 형태로 만들어진 난수를 유사 난수라고 한다.
- 유사 난수를 사용할 때는 시드 값이 적절하게 적용되는지 확인해야 한다.
- 예측이 가능하기에 다음과 같은 경우에는 절대로 유사 난수 생성 알고리즘을 사용해서는 안된다. 
- 액세스 토큰, API 시크릿, OTP 인증 코드, 접근 URL 등 권한을 증명하는 데 사용할 값을 생성할 때
- 생성된 난수를 기준으로 게임 아이템/ 재화를 결정할 때

#### 암호학적으로 안전한 난수
- 생성 속도가 상대적으로 느리지만 시드 값을 사용하지 않아서 예측이 불가능하다는 장점이 있다.

#### 공정한 난수, 셔플 백
- 예측할 수 없는 난수는 불공정한 게임을 만들지만, 그렇다고 확률을 없애면 게임 자체가 바뀌거나 재미가 없어진다.
- 이처럼 공정해보이는 난수가 필요하여 나온 것이 바로 셔플 백이다.
- 셔플 백이란 난수를 제어하는 기법으로 발생할 수 있는 모든 가능성을 한 가방에 넣고 섞는 방법.
- 당첨과 꽝의 비율은 항상 동일하지만 뽑는 순서만 난수를 적용하는 것.
- 전체 요소가 너무 많거나 확률이 희박할 경우, 모든 경우의 수를 담기 위해 필요한 컨테이너 크기가 커진다는 단점이 있다.

### 해시 함수
- 임의의 입력값을 고정된 길이의 해시 값으로 변환하는 함수
- 입력값이 동일하면, 해시 함수로 계산한 결과(해시 값)도 동일하다.
- 입력값의 길이와 상관 없이 해시 값의 길이는 항상 동일하다.
- 서로 다른 입력값이 동일한 해시 값을 만들(해시 충돌) 확률은 낮다.
- 암호학적으로 안전하려면 다음 조건도 만족해야 함.
```
제 1 역상 공격(해시 값으로 입력 값을 복원하는 방법)이 불가능해야 한다.
제 2 역상 공격(서로 다른 입력값으로 같거나 비슷한 해시 값을 찾는 방법)이 불가능해야 한다.
```
++) 취약점은 언제든지 발견될 수 있으므로, 암호학적으로 안전한 해시 함수는 '현 시점에서 안전하다'라는 뜻으로 이해해야 한다.

#### 해시 함수를 사용하는 곳
- 해시 함수를 이용하면 입력값이 이전에 저장한 값과 같은지 비교할 수 있다. ex) 비밀번호 검증
- 해시 함수를 이용하면 데이터가 변하지 않았다는 걸 보장할 수 있다. ex) 블록체인 거래 정보의 무결성 검증
++) 해시 함수가 데이터 암호화를 제공하지는 않으므로 인터넷을 통해 데이터를 주고 받을 때는 해시 값과 별개로 데이터 자체를 암호화할 필요가 있다. 그렇지 않다면, 해시 값 또한 변조될 위험이 있기 때문이다.

#### 종류
- MD5
- SHA-1
- SHA-2

- 안전한 해시 함수일수록 더 긴 길이를 사용한다.
- 때문에 해시 함수가 안전할수록, 계산하는 데 드는 비용도 커진다.

#### 실사용 예시
- 비밀번호와 같은 민감한 데이터를 보관
- 바이너리 데이터의 무결성 검증
- 해시 값을 키로 사용

#### 고민해야할 점
- 입력값의 크기
- 보안 수준
- 해시 값의 용도(값 자체가 의미를 지니거나 식별자로 사용하는 경우)
